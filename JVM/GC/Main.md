### GC

* GCRoots
* GC时机
* 标记算法
* 回收算法
* 单线程回收
* 多线程回收

#### GCRoots

`标记对象的根节点`

> 虚拟机栈中引用的对象(局部变量表)。

> 本地方法栈中引用的对象，通过JNI引用的java对象。

> 类静态变量引用的对象。

> 常量池中引用的对象。

> 同步锁(synchronized)持有的对象。

> 虚拟机内部的引用，基本类型对象的Class对象，常驻的异常对象。

#### GC时机

`为了优化STW的时间，发生GC的时机也很重要。`

###### 安全点

> 抢占式中断，虚拟机会中断所以线程，如果发现用户线程不在安全点上，会恢复线程继续运行直到到达安全点。几乎没有虚拟机采用。

> 主动式中断，线程执行到安全点时去轮询GC标志决定是否中断。

###### 安全区域

> 用户线程声明自己进入安全区域，GC线程就不管该线程了,当用户线程要离开安全区域时，会检查虚拟机是否完成GC Roots枚举。
>
> 如果完成了，就继续执行；
>
> 如果没有，需要等待完成后才能离开安全区域

#### 标记算法

* 引用计数法

  ###### 优点

  >及时性，当对象变成垃圾后，程序可以立刻感知，马上回收；而在可达性分析算法中，直到执行 GC 才能感知。

  > 最大暂停时间短，GC 可与应用交替运行。

         ###### 缺点

  > 计数器值更新频繁，大多数情况下，对象的引用状态会频繁更新，更新计数器值的任务会变得繁重。

  > 堆利用率降低，计数器至少占用 32 位空间（取决于机器位数），导致堆的利用率降低。

  >实现复杂。

  > 无法回收循环引用对象（致命缺陷）。

* 可达性分析

  ###### 优点

  >可回收循环引用对象。

  > 实现简单。

  ###### 缺点

  >最大停顿时间长，在 GC 期间，整个应用停顿(stop-the-world)。

  > 回收不及时，直到执行 GC 才能感知垃圾对象。

#### 回收算法

* 复制

  `新生代发生Minor/Young GC时采用的回收算法`

  ###### 优点

  > 快速分配对象，空闲分块是一个连续内存空间，不需要向标记-清理算法那样遍历空闲列表。

  > 避免内存碎片化，存活对象会被复制到From区，避免出现很多不连续的小内存。

  ###### 缺点

  > 堆利用率低，Eden区最多可利用90%。

* 清除

  `老年代发生Majar/Old GC 或者Full GC时可能采用的回收算法`

  ###### 优点

  > 实现简单

  ###### 缺点

  > 执行效率不稳定，Java 堆中对象越多，标记和清理的过程可能会越耗时。

  > 内存碎片化（fragmentation），回收过程会逐渐产生很多不连续的小内存，当小内存不足以分配对象内存时，又会触发一次垃圾回收动作（GC for Alloc）.

* 整理

  ` 老年代发生Majar/Old GC 或者Full GC时可能采用的回收算法`

  ###### 优点

  > 避免内存碎片化，堆利用率高，吞吐量更高。

  > 快速分配对象，空闲分块是一个连续内存空间，不需要向标记-清理算法那样遍历空闲列表。

  ###### 缺点

  > 移动对象比清理对象更耗时，导致 GC 停顿时间（Stop-the-world）时间更长。

##### 空间担保

> 当From区的存活对象到达一定时机时，发生几次GC后仍然存活，这个上线是15，不同的虚拟机次数要求不一样。

### 运行时数据区

* 方法区
* 堆
* 程序计数器
* 本地方法栈
* 虚拟机栈

> 方法区和堆是程序内存的公共区域，即所有线程都可以访问。程序计数器、本地方法栈和虚拟机栈是线程私有的。参考周志明《深入理解Java虚拟机_JVM高级特性与最佳实践_第3版》

#### 方法区

* 常量池
* 方法元信息
* 类元信息

> 方法区实现方案有永久代或元空间数据区

#### 堆

> 堆划分为老年代和新生代，默认比列是2:1。新生代又划分为Eden区、From区和To区(或者叫S0和S1区)，默认比列是8:1:1。

* 新生代
  * Eden
  * From
  * To
* 老年代

##### 新生代

> 对象一般都是朝生夕死，所以频繁创建发生在Eden区(伊甸园)，当Eden内存不够发生GC时，未被释放的对象会通过[复制算法]()复制到From区域，并清空Eden区域。如果From区空间不够，要释放内存时，也会通过复制算法将未被释放的对象复制到To区，然后清空From区，并交换From和To指向区域，即之前的From区变成To区，之前的To区变成From区。

##### 老年代

> 老年代的对象来自From区多次GC未被释放的对象或者创建的大对象。

#### 程序计数器

> 记录当前线程执行字节码的行号。

#### 本地方法栈

> 执行Native方法，与虚拟机栈类似。同样是线程私有。

#### 虚拟机栈

> 线程私有，生命周期与线程相同。描述Java方法执行的线程内存模型，每一个方法对应一个栈帧。

##### 栈帧结构

* 局部变量表
* 操作数栈
* 动态链接
* 方法返回地址

###### 局部变量表

> 局部变量表的容量以变量槽为最小单位，最大深度在编译时计算并写入，可以复用。存放着基本变量值或对象引用。非静态方法，第一个槽位存放this指针。

> Kotlin的方法扩展，可以定义一个静态方法，传入对象的指针来实现。

###### 操作数栈

> 同局部变量表一样最大深度在编译时计算并写入，在执行字节码指令时，不断出栈和压栈操作。

###### 动态连接

> 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，方便方法调用过程中的动态连接。

> Class一般持有常量池中的大量符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，即静态解析。另一部分将在每一次运行期间转化为直接引用，即动态连接。

###### 方法返回地址

> 正常调用完成，即调用返回指令，PC计数器的值可以作为返回地址，栈帧中很可能保存这个计数器的值。

> 执行遇到异常退出，返回地址通过异常处理器表来确定，栈帧中一般不会保存这部分信息。	
